Timer_P - аналогия блока Timer_P(FB5) промышленных логических контроллеров (PLC) Siematic Siemens  
Класс Timer_P имеет 3 публичных метода, публичные свойства отсутствуют.
  Timer_P() - конструктор класса, вызывается при декларации объекта класса Timer_P, аргументы отсутствуют.
  boolean Timer(boolean Condition, boolean Reset,int Mode, long Duration) - основной метод работы таймера
	Аргументы:
	- boolean Condition - условие запуска таймера
	- boolean Reset - условие принудительного сброса таймера
	- int Mode - режим работы таймера (0...4) см. временную диаграмму Timer_P.png
	- long Duration - длительность работы таймера в миллисекундах
	возвращает признак срабатывания таймера
  long GetRemains() - оставшееся время до срабатывания таймера в миллисекундах.
 
Timer_P работает с фронтами сигналов, поэтому очень чувствителен к дребезгу входных сигналов.
Для того, чтобы использовать Timer_P для входов Arduino рекомендуется "пропускать" их через класс DI.

Класс DI используется для программой фильтрации дребезга контакта.
Класс DI имеет 3 публичных метода, публичные свойства отсутствуют.
  DI(int PIN, long Duration)  конструктор класса, вызывается при декларации объекта класса DI.
	Аргументы:
	- int PIN - номер пина Arduino
	- long Duration - длительность времени фильтрации.
  boolean DI_Read() - считывание фильтрованного входа, возвращает фильтрованное значени входа.
  void DI_Refresh() - обновление входа, связанного с объектом класса.
Делать pinMode для входов используемых для DI не нужно. Они инициализируются при создании объекта класса DI.
При работе со входами используется INPUT_PULLUP-режим. Значения входов нормализовываются во время обработки класса.
Замкнутая кнопка - логическая 1 в DI. 

Пример использования классов в скетче Arduino 
-------------------------------------------------
    #include <DI.h>         //подключаем библиотеку DI - обработка дискретного входа из набора библиотек от X-Dron  
    #include <Timer_P.h>    //подключаем библиотеку Timer_P - работа с таямерами из набора библиотек от X-Dron

    #define Condition_PIN 2     //PIN кнопки условия работы таймера 
    #define Reset_PIN 3         //PIN кнопки сброса таймера
    #define QTimer_PIN 7        //PIN светодиода работы таймера
    #define QReset_PIN 8        //PIN светодиода сброса таймера
    
    Timer_P Timer_Test;                                //создание и инициализация объекта Timer_Test класса Timer_P
    // Создание объектов типа "Дистретный вход" они посажены описанные выше пины. Фильтр антидребезга 30мс.
    DI Condition_IN(Condition_PIN, 30);              
    DI Reset_IN(Reset_PIN, 30);
    
    void setup() {
      //Режимы выходов 
      pinMode(QTimer_PIN, OUTPUT);
      pinMode(QReset_PIN, OUTPUT);     
      //делать pinMode для входов не нужно. Они инициализируются при создании объекта класса DI см. DI.cpp
      //при работе со входами используется INPUT_PULLUP-режим. Значения входов нормализовываются во время обработки класса.
      //замкнутая кнопка - логическая 1. 
    }
    
    void loop() {
      // Обновляем значение дискретных входов
      // Производится их считывание с пинов и фильтрация через внутреннюю переменную класса.
      Condition_IN.DI_Refresh();
      Reset_IN.DI_Refresh();
      
      //Считываем состояние фильтрованной кнопки сброса таймера и выводим его на лампочку.
      digitalWrite(QReset_PIN, Reset_IN.DI_Read());
      
      //Запускаем таймер по фильтрованной кнопке запуска таймера.
      //Сброс выполнения таймера по фильтрованной кнопке сброса таймера.
      //Режим работы таймера - Mode = 1 extended pulse 
      //Время работы таймера - 1900мс.
      //Результат работы таймера выводим на светодиод работы таймера 
      digitalWrite(QTimer_PIN, Timer_Test.Timer(Condition_IN.DI_Read(), Reset_IN.DI_Read(), 1, 1900));
      
      //Получаем значение отсрочки срабатывания таймера
      long T_Remains = Timer_Test.GetRemains();
    } 
-------------------------------------------------